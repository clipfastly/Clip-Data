
# 1. Program: Tic-Tac-Toe Game


# Function to print the Tic-Tac-Toe board
def print_board(board):
    for row in board:
        print(" | ".join(row))
    print("-" * 9)

# Function to check if the current player has won
def check_winner(board, player):
    # Check rows and columns
    for i in range(3):
        if all(board[i][j] == player for j in range(3)):  # Check each row
            return True
        if all(board[j][i] == player for j in range(3)):  # Check each column
            return True

    # Check both diagonals
    if all(board[i][i] == player for i in range(3)) or all(board[i][2 - i] == player for i in range(3)):
        return True

    return False  # No winning condition yet

# Function to check if the board is full (for draw)
def is_board_full(board):
    for row in board:
        if " " in row:
            return False
    return True

# Main function
def main():
    board = [[" " for _ in range(3)] for _ in range(3)]  # Create 3x3 board
    players = ["X", "O"]
    turn = 0

    print("Welcome to Tic-Tac-Toe Game!\n")
    print_board(board)

    while True:
        player = players[turn % 2]  # Alternates between X and O
        print(f"Player {player}'s turn")

        # Take input for row and column
        row = int(input("Enter row (0, 1, or 2): "))
        col = int(input("Enter column (0, 1, or 2): "))

        # Check if the cell is empty
        if board[row][col] == " ":
            board[row][col] = player  # Place player's move
            print_board(board)

            # Check for a winner
            if check_winner(board, player):
                print(f"Player {player} wins! ðŸŽ‰")
                break
            # Check for a draw
            elif is_board_full(board):
                print("It's a draw! ðŸ¤")
                break

            turn += 1  # Switch turn
        else:
            print("Cell already occupied! Try again.\n")

# Run the main function
if __name__ == "_main_":
    main()

---------------------------------------------------------------------------------------------------------------


# Water Jug Problem using simple rules

x = 0   # Current amount of water in jug X (capacity 4)
y = 0   # Current amount of water in jug Y (capacity 3)
m = 4   # Capacity of jug X
n = 3   # Capacity of jug Y

print("Initial state = (0, 0)")
print("Capacities = (4, 3)")
print("Goal state = (2, y)")

while x != 2:   # Continue until jug X has 2 liters
    r = int(input("Enter the rule (1-8): "))

    if r == 1:      # Fill jug X completely
        x = m
    elif r == 2:    # Fill jug Y completely
        y = n
    elif r == 3:    # Empty jug X
        x = 0
    elif r == 4:    # Empty jug Y
        y = 0
    elif r == 5:    # Pour water from Y into X until X is full or Y is empty
        t = min(n - y, x)
        y = y + t
        x = x - t
    elif r == 6:    # Pour water from X into Y until Y is full or X is empty
        t = min(m - x, y)
        x = x + t
        y = y - t
    elif r == 7:    # Pour all water from X into Y
        y += x
        x = 0
    elif r == 8:    # Pour all water from Y into X
        x += y
        y = 0
    else:
        print("Invalid rule")

    print(f"Current state: ({x}, {y})")

print("Goal reached!")


-----------------------------------------------------------------------------------------------------------------------------------------

# 3. 8 Puzzle Program


# Importing required libraries
import numpy as np
import pandas as pd
import os

# Breadth First Search (BFS) function
def bfs(src, target):
    queue = []              # List to store states to be explored
    explored = []           # List to store already visited states

    queue.append(src)       # Add the starting state to the queue

    while len(queue) > 0:   # Repeat until queue becomes empty
        state = queue.pop(0)    # Take the first state from the queue
        explored.append(state)  # Mark it as explored
        print(state)            # Print the current state

        if state == target:     # If we reached the goal
            print("Success! Target state reached.")
            return

        # Find all possible next moves from the current state
        for move in possible_moves(state, explored):
            if move not in explored and move not in queue:
                queue.append(move)   # Add new states to queue for exploring

# Function to find possible moves from a given state
def possible_moves(state, visited_states):
    pos = state.index(0)    # Find the position of the empty tile (0)
    moves = []              # List to store allowed moves

    # Based on the empty tile position, decide possible directions
    if pos not in [0, 1, 2]: moves.append('u')   # Can move up
    if pos not in [6, 7, 8]: moves.append('d')   # Can move down
    if pos not in [0, 3, 6]: moves.append('l')   # Can move left
    if pos not in [2, 5, 8]: moves.append('r')   # Can move right

    # Generate new states based on valid moves
    new_states = []
    for m in moves:
        new_states.append(generate(state, m, pos))

    # Return only new states not already visited
    return [s for s in new_states if s not in visited_states]

# Function to generate new state after a move
def generate(state, move, pos):
    temp = state.copy()     # Copy current state to modify safely

    # Swap the blank tile (0) based on the move direction
    if move == 'u': temp[pos-3], temp[pos] = temp[pos], temp[pos-3]
    if move == 'd': temp[pos+3], temp[pos] = temp[pos], temp[pos+3]
    if move == 'l': temp[pos-1], temp[pos] = temp[pos], temp[pos-1]
    if move == 'r': temp[pos+1], temp[pos] = temp[pos], temp[pos+1]

    return temp

# Starting and target states
src = [1, 2, 3, 4, 5, 6, 0, 7, 8]
target = [1, 2, 3, 4, 5, 6, 7, 8, 0]

# Run BFS search
bfs(src, target)


------------------------------------------------------------------------------------------------------------------



#4. AO* Algorithm Implementation (Simplified and Correct)

class Node:
    def _init_(self, name, heuristic, is_goal=False):
        self.name = name               # Node name
        self.heuristic = heuristic     # Estimated cost (heuristic value)
        self.is_goal = is_goal         # True if this node is a goal
        self.children = []             # Child node sets (AND/OR)
        self.marked = False            # Marked means part of the optimal path

    def add_children(self, *child_sets):
        # Each child_set is a list of children (representing AND/OR groups)
        self.children.extend(child_sets)

def ao_star(node, path_cost=1):
    """AO* Search: Finds minimum cost path"""
    if node.is_goal:              # If goal reached
        node.marked = True
        return node.heuristic

    if not node.children:         # If no children, return heuristic value
        return node.heuristic

    min_cost = float('inf')
    best_child_set = None

    # Check each child set (AND/OR combinations)
    for child_set in node.children:
        cost = 0
        for child in child_set:
            # Total cost = heuristic + path cost
            cost += child.heuristic + path_cost
            if not child.marked:
                cost += ao_star(child, path_cost)

        # Update best (minimum) cost and best set
        if cost < min_cost:
            min_cost = cost
            best_child_set = child_set

    # Mark the best path
    if best_child_set:
        node.marked = True
        for child in best_child_set:
            child.marked = True

    return min_cost

# --- Create nodes ---
A = Node('A', 6)
B = Node('B', 4)
C = Node('C', 2)
D = Node('D', 0, is_goal=True)
E = Node('E', 0, is_goal=True)
F = Node('F', 0, is_goal=True)
G = Node('G', 0, is_goal=True)

# --- Define AND/OR relationships ---
A.add_children([B], [C])      # A â†’ B OR C
B.add_children([D], [E])      # B â†’ D OR E
C.add_children([F], [G])      # C â†’ F OR G

# --- Run AO* algorithm ---
print("Running AO* algorithm...")
total_cost = ao_star(A)
print("Optimal solution path cost:", total_cost)

# --- Display the optimal path ---
def display_solution_path(node):
    if node.marked:
        print(node.name, end=" ")
        for child_set in node.children:
            for child in child_set:
                display_solution_path(child)

print("\nOptimal solution path:")
display_solution_path(A)


------------------------------------------------------------------------------------------------------------------------


#5. Find S

import csv   # Used to read CSV files

num_attributes = 6   # Total number of attributes (columns)

# Open and read the dataset file
with open('enjoysport.csv', 'r') as file:
    reader = csv.reader(file)
    data = list(reader)

# Assume first positive example as the initial hypothesis
hypothesis = data[1][:-1]

# Go through each training example
for row in data:
    if row[-1].lower() == 'yes':        # Check if example is positive
        for j in range(num_attributes): # Compare each attribute
            if row[j] != hypothesis[j]: # If different, replace with '?'
                hypothesis[j] = '?'

# Display final hypothesis
print("\nThe maximally specific hypothesis is:\n")
print(hypothesis)


------------------------------------------------------------------------------------------------------------------------


# 6. Candidate Elimination
import csv

# Step 1: Read the training data file
with open('trainingdata.csv', 'r') as f:
    reader = csv.reader(f)
    data = list(reader)

# Step 2: Initialize S (specific hypothesis) as the first positive example
s = data[1][:-1]  # Ignore last column (target value)
print("Initial Specific Hypothesis:", s)

# Step 3: Initialize G (general hypothesis) with most general values
g = [['?' for _ in range(len(s))]]
print("Initial General Hypothesis:", g)

# Step 4: Loop through each training example
for i in data:
    if i[-1].lower() == "yes":  # Positive example
        for j in range(len(s)):
            if i[j] != s[j]:     # If attribute differs, make it '?'
                s[j] = '?'
    elif i[-1].lower() == "no":  # Negative example
        for j in range(len(s)):
            if s[j] != '?' and s[j] == i[j]:
                g[0][j] = '?'

    # Print intermediate steps
    print("\nStep", data.index(i)+1)
    print("Specific Hypothesis:", s)
    print("General Hypothesis:", g)

# Step 5: Display final hypotheses
print("\nFinal Specific Hypothesis:", s)
print("Final General Hypothesis:", g)


------------------------------------------------------------------------------------------------------------------------

// Client Program

#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <fcntl.h> // for open
#include <unistd.h> // for close
#include <arpa/inet.h>

#define MAX 80
#define PORT 8080
#define SA struct sockaddr
void func(int sockfd)
{
    char buff[MAX];
    int n;
    for (;;) {
        bzero(buff, sizeof(buff));
        printf("Enter the string : ");
        n = 0;
        while ((buff[n++] = getchar()) != '\n')
            ;
        write(sockfd, buff, sizeof(buff));
        bzero(buff, sizeof(buff));
        read(sockfd, buff, sizeof(buff));
        printf("From Server : %s", buff);
        if ((strncmp(buff, "exit", 4)) == 0) {
            printf("Client Exit...\n");
            break;
        }
    }
}
   
int main()
{
    int sockfd, connfd;
    struct sockaddr_in servaddr, cli;
   
    // socket create and verification
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        printf("socket creation failed...\n");
        exit(0);
    }
    else
        printf("Socket successfully created..\n");
    bzero(&servaddr, sizeof(servaddr));
   
    // assign IP, PORT
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = inet_addr("127.0.0.1");
    servaddr.sin_port = htons(PORT);
   
    // connect the client socket to server socket
    if (connect(sockfd, (SA*)&servaddr, sizeof(servaddr)) != 0) {
        printf("connection with the server failed...\n");
        exit(0);
    }
    else
        printf("connected to the server..\n");
   
    // function for chat
    func(sockfd);
   
    // close the socket
    close(sockfd);
}


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Server Program

#include <stdio.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <fcntl.h> 
#include <unistd.h> 
#define MAX 80
#define PORT 8080
#define SA struct sockaddr
void func(int connfd)
{
    char buff[MAX];
    int n;
    for (;;) {
        bzero(buff, MAX);
        read(connfd, buff, sizeof(buff));
        printf("From client: %s\t To client : ", buff);
        bzero(buff, MAX);
        n = 0;
        while ((buff[n++] = getchar()) != '\n');
        write(connfd, buff, sizeof(buff));
        if (strncmp("exit", buff, 4) == 0) {
            printf("Server Exit...\n");
            break;
        }
    }
}
int main()
{
    int sockfd, connfd, len;
    struct sockaddr_in servaddr, cli;
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        printf("socket creation failed...\n");
        exit(0);
    }
    else
        printf("Socket successfully created..\n");
    bzero(&servaddr, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    servaddr.sin_port = htons(PORT);
    if ((bind(sockfd, (SA*)&servaddr, sizeof(servaddr))) != 0) {
        printf("socket bind failed...\n");
        exit(0);
    }
    else
        printf("Socket successfully binded..\n");
    if ((listen(sockfd, 5)) != 0) {
        printf("Listen failed...\n");
        exit(0);
    }
    else
        printf("Server listening..\n");
    len = sizeof(cli);
    connfd = accept(sockfd, (SA*)&cli, &len);
    if (connfd < 0) {
        printf("server accept failed...\n");
        exit(0);
    }
    else
        printf("server accept the client...\n");
    func(connfd);
    close(sockfd);
}




